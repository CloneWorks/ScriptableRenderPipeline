#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/BSDF.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightDefinition.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/AtmosphericScattering/AtmosphericScattering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/CookieSampling.hlsl"

#define DEBUG

#define MAKE_FLT(sgn, exponent, fraction) asfloat((((sgn) & 0x1) << 31) | (((exponent) & 0xFF) << 23) | ((fraction) & 0xFFFFFF))
#define FLT_SNAN MAKE_FLT(0x1, 0xFF, 0x1)
#ifdef DEBUG
    #define assert(x) if (!(bool)(x)) return FLT_SNAN
#else  // DEBUG
    #define assert(x) x
#endif // DEBUG

static const uint s_RandomPrimes[10] = { 0xD974CF83, 0xFAF269B5, 0xAE727FA9, 0x5BA52335, 0xA4E819D5, 0xDD638559, 0xC0972367, 0x4B190D9B, 0xD1894DB5, 0xA78BCBB3 };

TEXTURECUBE(_GroundAlbedoTexture);
TEXTURECUBE(_GroundEmissionTexture);
TEXTURECUBE(_SpaceEmissionTexture);

RW_TEXTURE2D_X(float4, _ColorBuffer);

int _HasGroundAlbedoTexture;    // bool...
int _HasGroundEmissionTexture;  // bool...
int _HasSpaceEmissionTexture;   // bool...
int _RenderSunDisk;             // bool...

float _GroundEmissionMultiplier;
float _SpaceEmissionMultiplier;
uint  _DispatchThreadCount;
uint  _DispatchWidth;
uint  _PassIndex;
uint  _BounceCount;
uint  _NumPaths;

// 3x3, but Unity can only set 4x4...
float4x4 _PlanetRotation;
float4x4 _SpaceRotation;

struct Ray
{
    float3 origin;
    float3 direction;
    float  frequency;
    float  maxDist;
};

// 'l' is the length of the permutation vector (e.g. the number of strata per dimension).
uint permute(uint i, uint l, uint p)
{
    assert(l != 0);

    if (p == 0) return i; // Identity permutation when (p == 0)

    uint w = l - 1;

    w |= w >> 1;
    w |= w >> 2;
    w |= w >> 4;
    w |= w >> 8;
    w |= w >> 16;
    do
    {
        i ^= p; i *= 0xe170893d;
        i ^= p >> 16;
        i ^= (i & w) >> 4;
        i ^= p >> 8; i *= 0x0929eb3f;
        i ^= p >> 23;
        i ^= (i & w) >> 1; i *= 1 | p >> 27;
        i *= 0x6935fa69;
        i ^= (i & w) >> 11; i *= 0x74dcb303;
        i ^= (i & w) >> 2;  i *= 0x9e501cc3;
        i ^= (i & w) >> 2;  i *= 0xc860a3df;
        i &= w;
        i ^= i >> 5;
    } while (i >= l);

    return (i + p) % l;
}

float randfloat(uint i, uint p)
{
    if (p == 0) return 0.5f; // always 0.5 when (p == 0)

    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10; i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21; i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17; i *= 1 | p >> 18;

    float f = i * (1.0f / 4294967808.0f);

    assert(0 <= f && f < 1);

    return f;
}

// Multi-dimensional correlated multi-jittered sequence.
// We specialize it for 6D, which means we generate s^6 points.
float cmj6D(uint pointIndex, uint dimIndex, uint seed)
{
    dimIndex = dimIndex % (6 - 1);

    const uint s = 4;           // Number of strata per dimension
    const uint t = 6;           // Strength of the orthogonal array (number of dimensions)
    const uint n = 4096;        // Size of the sequence: n = s^t
    const uint p = seed;        // Pseudo-random permutation seed
    const uint i = permute(pointIndex, n, p); // Shuffle the points
    const uint j = dimIndex;

    assert(i < n);
    assert(j < t);

    const uint p1 = (p * (j + 1)) * 0x51633e2d;
    const uint p2 = (p * (j + 1)) * 0x68bc21eb;
    const uint p3 = (p * (j + 1)) * 0x02e5be93;

    // TODO: we do not actually need 't' registers.
    // The compiler should be able to fuse the loops below.
    // This formulation is retained for comparison with the reference implementation.
    uint digits[t];

    uint k = i, d = 0;

    // digits = toBaseS(i, s);
    for (d = 0; d < t; k /= s, d++)
    {
        digits[d] = k % s;
    }

    uint stratum = permute(digits[j], s, p1);

    uint poly = 0;

    // digits = allButJ(digits, j);
    // poly   = evalPoly(digits, s);
    for (d = (t - 1); d != j; d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }
    for (d = (j - 1); d != uint(-1); d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }

    uint  stm      = n / s; // pow(s, t - 1)
    uint  sStratum = permute(poly, stm, p2);
    float jitter   = randfloat(i, p3);
    float result   = (stratum + (sStratum + jitter) / stm);

    return result / s;
}

#define fmaf(a, b, c) ((a) * (b) + (c))

// Computes (Exp[x^2] * Erfc[x]) for (x >= 0).
// Range of inputs:  [0, Inf].
// Range of outputs: [0, 1].
// Max Abs Error: 0.000000969658452.
// Max Rel Error: 0.000001091639525.
float Exp2Erfc(float x)
{
    float t, u, y;

    t = 3.9788608f * rcp(x + 3.9788608f); // Reduce the range
    u = t - 0.5f;                         // Center around 0

    y =           -0.010297533124685f;
    y = fmaf(y, u, 0.288184314966202f);
    y = fmaf(y, u, 0.805188119411469f);
    y = fmaf(y, u, 1.203098773956299f);
    y = fmaf(y, u, 1.371236562728882f);
    y = fmaf(y, u, 1.312000870704651f);
    y = fmaf(y, u, 1.079175233840942f);
    y = fmaf(y, u, 0.774399876594543f);
    y = fmaf(y, u, 0.490166693925858f);
    y = fmaf(y, u, 0.275374621152878f);

    return y * t; // Expand the range
}

float ChapmanUpper(float z, float absCosTheta)
{
    float sinTheta = sqrt(saturate(1 - absCosTheta * absCosTheta));

    float zm12 = rsqrt(z);           // z^(-1/2)
    float zp12 = z * zm12;           // z^(+1/2)

    float tp   = 1 + sinTheta;       // 1 + Sin
    float rstp = rsqrt(tp);          // 1 / Sqrt[1 + Sin]
    float rtp  = rstp * rstp;        // 1 / (1 + Sin)
    float stm  = absCosTheta * rstp; // Sqrt[1 - Sin] = Abs[Cos] / Sqrt[1 + Sin]
    float arg  = zp12 * stm;         // Sqrt[z - z * Sin], argument of Erfc
    float e2ec = Exp2Erfc(arg);      // Exp[x^2] * Erfc[x]

    // Term 1 of Equation 46.
    float mul1 = absCosTheta * rtp;  // Sqrt[(1 - Sin) / (1 + Sin)] = Abs[Cos] / (1 + Sin)
    float trm1 = mul1 * (1 - 0.5 * rtp);

    // Term 2 of Equation 46.
    float mul2 = SQRT_PI * rstp * e2ec; // Sqrt[Pi / (1 + Sin)] * Exp[x^2] * Erfc[x]
    float trm2 = mul2 * (zp12 * (-1.5 + tp + rtp) +
                         zm12 * 0.25 * (2 * tp - 1) * rtp);
    return trm1 + trm2;
}

float ChapmanHorizontal(float z)
{
    float zm12 = rsqrt(z);           // z^(-1/2)
    float zm32 = zm12 * zm12 * zm12; // z^(-3/2)

    float p = -0.14687275046666018 + z * (0.4699928014933126 + z * 1.2533141373155001);

    // Equation 47.
    return p * zm32;
}

// z = (r / H), Z = (R / H).
float RescaledChapman(float z, float Z, float cosTheta)
{
    float sinTheta = sqrt(saturate(1 - cosTheta * cosTheta));

    // Cos[Pi - theta] = -Cos[theta],
    // Sin[Pi - theta] =  Sin[theta],
    // so we can just use Abs[Cos[theta]].
    float ch = ChapmanUpper(z, abs(cosTheta)) * exp(Z - z); // Rescaling adds 'exp'

    if (cosTheta < 0)
    {
        // Ch[z, theta] = 2 * Exp[z - z_0] * Ch[z_0, Pi/2] - Ch[z, Pi - theta].
        // z_0 = r_0 / H = (r / H) * Sin[theta] = z * Sin[theta].
        float z_0 = z * sinTheta;
        float chP = ChapmanHorizontal(z_0) * exp(Z - z_0); // Rescaling adds 'exp'

        // Equation 48.
        ch = 2 * chP - ch;
    }

    return ch;
}

#define spectrum float3

float RadAtDist(float r, float rRcp, float cosTheta, float s)
{
    float x2 = 1 + (s * rRcp) * ((s * rRcp) + 2 * cosTheta);

    // Equation 38.
    return r * sqrt(x2);
}

float CosAtDist(float r, float rRcp, float cosTheta, float s)
{
    float x2 = 1 + (s * rRcp) * ((s * rRcp) + 2 * cosTheta);

    // Equation 39.
    return ((s * rRcp) + cosTheta) * rsqrt(x2);
}

// This variant of the function evaluates optical depth along an infinite path.
// 'r' is the radial distance from the center of the planet.
// 'cosTheta' is the value of the dot product of the ray direction and the surface normal.
// seaLvlAtt = (sigma_t * k) is the sea-level (height = 0) attenuation coefficient.
// 'R' is the radius of the planet.
// n = (1 / H) is the falloff exponent, where 'H' is the scale height.
spectrum OptDepthSpherExpMedium(float r, float cosTheta, float R,
                                spectrum seaLvlAtt, float H, float n)
{
    float z = r * n;
    float Z = R * n;

    float ch = RescaledChapman(z, Z, cosTheta);

    return ch * H * seaLvlAtt;
}

// This variant of the function evaluates optical depth along a bounded path.
// 'r' is the radial distance from the center of the planet.
// rRcp = (1 / r).
// 'cosTheta' is the value of the dot product of the ray direction and the surface normal.
// 'dist' is the distance.
// seaLvlAtt = (sigma_t * k) is the sea-level (height = 0) attenuation coefficient.
// 'R' is the radius of the planet.
// n = (1 / H) is the falloff exponent, where 'H' is the scale height.
spectrum OptDepthSpherExpMedium(float r, float rRcp, float cosTheta, float dist, float R,
                                spectrum seaLvlAtt, float H, float n)
{
    float rX        = r;
    float rRcpX     = rRcp;
    float cosThetaX = cosTheta;
    float rY        = RadAtDist(rX, rRcpX, cosThetaX, dist);
    float cosThetaY = CosAtDist(rX, rRcpX, cosThetaX, dist);

    // Potentially swap X and Y.
    // Convention: at the point Y, the ray points up.
    cosThetaX = (cosThetaY >= 0) ? cosThetaX : -cosThetaX;

    float zX  = rX * n;
    float zY  = rY * n;
    float Z   = R  * n;

    float chX = RescaledChapman(zX, Z, cosThetaX);
    float chY = ChapmanUpper(zY, abs(cosThetaY)) * exp(Z - zY); // Rescaling adds 'exp'

    // We may have swapped X and Y.
    float ch = abs(chX - chY);

    return ch * H * seaLvlAtt;
}

float ConvertCdfToOpticalDepth(float cdf, float viewOpacity)
{
    // Equation 24.
    return -log(1 - cdf * viewOpacity);
}

#define EPS_ABS  0.0001
#define EPS_REL  0.0001
#define MAX_ITER 4

// 'optDepth' is the value to solve for.
// 'maxOptDepth' is the maximum value along the ray, s.t. (maxOptDepth >= optDepth).
// 'maxDist' is the maximum distance along the ray.
float SampleSpherExpMedium(float optDepth, float r, float rRcp, float cosTheta, float R,
                           float2 seaLvlAtt, float2 H, float2 n, // Air & aerosols
                           float maxOptDepth, float maxDist)
{
    const float  optDepthRcp = rcp(optDepth);
    const float2 Z           = R * n;

    // Make an initial guess (homogeneous assumption).
    float t = maxDist * (optDepth * rcp(maxOptDepth));

    // Establish the ranges of valid distances ('tRange') and function values ('fRange').
    float tRange[2], fRange[2];
    tRange[0] = 0;        /* -> */  fRange[0] = 0           - optDepth;
    tRange[1] = maxDist;  /* -> */  fRange[1] = maxOptDepth - optDepth;

    uint  iter = 0;
    float absDiff = optDepth, relDiff = 1;

    do // Perform a Newton–Raphson iteration.
    {
        float radAtDist = RadAtDist(r, rRcp, cosTheta, t);
        float cosAtDist = CosAtDist(r, rRcp, cosTheta, t);
        // Evaluate the function and its derivatives:
        // f  [t] = OptDepthAtDist[t] - GivenOptDepth = 0,
        // f' [t] = AttCoefAtDist[t],
        // f''[t] = AttCoefAtDist'[t] = -AttCoefAtDist[t] * CosAtDist[t] / H.
        float optDepthAtDist = 0, attAtDist = 0, attAtDistDeriv = 0;
        optDepthAtDist += OptDepthSpherExpMedium(r, rRcp, cosTheta, t, R,
                                                 seaLvlAtt.x, H.x, n.x);
        optDepthAtDist += OptDepthSpherExpMedium(r, rRcp, cosTheta, t, R,
                                                 seaLvlAtt.y, H.y, n.y);
        attAtDist      += seaLvlAtt.x * exp(Z.x - radAtDist * n.x);
        attAtDist      += seaLvlAtt.y * exp(Z.y - radAtDist * n.y);
        attAtDistDeriv -= seaLvlAtt.x * exp(Z.x - radAtDist * n.x) * n.x;
        attAtDistDeriv -= seaLvlAtt.y * exp(Z.y - radAtDist * n.y) * n.y;
        attAtDistDeriv *= cosAtDist;

        float   f = optDepthAtDist - optDepth;
        float  df = attAtDist;
        float ddf = attAtDistDeriv;
        float  dg = df - 0.5 * f * (ddf * rcp(df));

        assert(df > 0 && dg > 0);

    #if 0
        // https://en.wikipedia.org/wiki/Newton%27s_method
        float slope = rcp(df);
    #else
        // https://en.wikipedia.org/wiki/Halley%27s_method
        float slope = rcp(dg);
    #endif

        float dt = -f * slope;

        // Find the boundary value we are stepping towards:
        // supremum for (f < 0) and infimum for (f > 0).
        uint  sgn     = asuint(f) >> 31;
        float tBound  = tRange[sgn];
        float fBound  = fRange[sgn];
        float tNewton = t + dt;

        bool isInRange = tRange[0] < tNewton && tNewton < tRange[1];

        if (!isInRange)
        {
            // The Newton's algorithm has effectively run out of digits of precision.
            // While it's possible to continue improving precision (to a certain degree)
            // via bisection, it is costly, and the convergence rate is low.
            // It's better to recall that, for short distances, optical depth is a
            // linear function of distance to an excellent degree of approximation.
            slope = (tBound - t) * rcp(fBound - f);
            dt    = -f * slope;
            iter  = MAX_ITER;
        }

        tRange[1 - sgn] = t; // Adjust the range using the
        fRange[1 - sgn] = f; // previous values of 't' and 'f'

        t = t + dt;

        absDiff = abs(optDepthAtDist - optDepth);
        relDiff = abs(optDepthAtDist * optDepthRcp - 1);

        iter++;

        // Stop when the accuracy goal has been reached.
        // Note that this uses the accuracy corresponding to the old value of 't'.
        // The new value of 't' we just computed should result in higher accuracy.
    } while ((absDiff > EPS_ABS) && (relDiff > EPS_REL) && (iter < MAX_ITER));

    return t;
}

#define GROUP_SIZE_1D 8 // 8^2 == 64
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define TILE_SIZE_1D  4 // 4^2 == 16

// 1x path per thread per call.
// Tracing multiple paths can be achieved via multiple passes (0 <= passIndex < 256).
// Do not access globals from within a pure function.
float3 PathTraceSky(uint2 groupCoordInDispatch, uint groupIndexInDispatch,
                    uint2 threadCoordInGroup, uint threadCountInDispatch,
                    uint groupSize1D, uint tileSize1D, uint bounceCount, uint passIndex,
                    float3 rayOrigin, out uint2 positionSS)
{
    float radiance[3];
    ZERO_INITIALIZE_ARRAY(float, radiance, 3);

    uint tileSize2D      = tileSize1D * tileSize1D;
    uint tilesPerGroup1D = groupSize1D / tileSize1D;
    uint tilesPerGroup2D = Sq(tilesPerGroup1D);

    // Integral over ((1 + NumBounces) * 3) dimensions:
    // 2x for filter IS + 1x for photon frequency selection (bounce #0);
    // 1x for scattering location + 2x for the scattering direction (bounce #i).
    uint dimCount = bounceCount * 3 + 3;

    // We constrain our RNG to 6 dimensions.
    // We generate 4096 (4^6) paths stratified into 4 intervals per dimension.
    // That gives us 256 spp within a 4x4 tile of pixels.
    // The stratification properties of Orthogonal Arrays guarantee 256 spp, but make no promises
    // about the uniformity of the distribution within each individual pixel (or stratum).
    // TODO: it seems we get between 249-257 spp. Floating-point issue?
    // As for the order of generated points, every single pass produces 1spp on average,
    // but this could mean several samples for one pixel and 0 for another.
    // Therefore, we must use atomics for accumulation.
    uint2 tileCoordInGroup    = threadCoordInGroup / tileSize1D;
    uint  tileIndexInGroup    = tileCoordInGroup.y * tilesPerGroup1D + tileCoordInGroup.x;
    uint  tileIndexInDispatch = groupIndexInDispatch * tilesPerGroup2D + tileIndexInGroup;
    uint  tileCountInDispatch = threadCountInDispatch / tileSize2D;
    uint2 threadCoordInTile   = threadCoordInGroup % tileSize1D;
    uint  threadIndexInTile   = threadCoordInTile.y * tileSize1D + threadCoordInTile.x;
    uint  pointIndex          = tileSize2D * passIndex + threadIndexInTile; // Tile of points per pass

    uint bounce = 0;

    // We generate a unique point set per tile every 2 bounces.
    uint   seed = permute(tileIndexInDispatch, tileCountInDispatch, s_RandomPrimes[bounce / 2]);
    float3 rnd  = float3(cmj6D(pointIndex, bounce * 3 + 0, seed),
                         cmj6D(pointIndex, bounce * 3 + 1, seed),
                         cmj6D(pointIndex, bounce * 3 + 2, seed));

    // Determine which pixel the path contributes to.
    float2 filterOffset    = rnd.xy; // TODO: do not use a box filter?
    float2 intraTileOffset = filterOffset * tileSize1D;

    positionSS = groupSize1D * groupCoordInDispatch
               + tileSize1D  * tileCoordInGroup
               + (uint2)intraTileOffset;

    float2 screenCoord = positionSS + frac(intraTileOffset);

    Ray ray; // Pinhole camera...

    // Point away from the camera into the scene.
    ray.direction = -normalize(mul(float4(screenCoord, 1, 1), _PixelCoordToViewDirWS).xyz);
    ray.origin    = rayOrigin;
    ray.frequency = floor(rnd.z * 3); // Color channel, for now...

    // Our atmosphere, theoretically, extends to infinity but, numerically,
    // its density exponentially falls off to zero pretty quickly.
    const float A    = _AtmosphericRadius;
    const float R    = _PlanetaryRadius;
    const float RRcp = _RcpPlanetaryRadius;

    // Reparametrize the ray.
    float r, rSq, rRcp, cosTheta;
    ApplySphericalSymmetry(ray.origin, ray.direction, /* -> */ r, rSq, rRcp, cosTheta);

    float2 atmosEntryExit = IntersectSphere(A, cosTheta, r, rRcp);
    bool   hitAtmosphere  = atmosEntryExit.y > 0;

    if (!hitAtmosphere)
    {
        return 0; // TODO: sample the space emission texture.
    }

    // Do not path trace outside the atmosphere.
    if (atmosEntryExit.x > 0)
    {
        ray.origin += atmosEntryExit.x * ray.direction;
        // Careful: we may end up on the edge of the atmosphere and, numerically, outside.
        ray.origin *= (1 - 1e-6); // 2 orders of magnitude larger than FLT_EPS

        // Update ray parameters.
        ApplySphericalSymmetry(ray.origin, ray.direction, /* -> */ r, rSq, rRcp, cosTheta);

        atmosEntryExit.y -= atmosEntryExit.x;
        atmosEntryExit.x  = 0;
    }

    float tGround = IntersectSphere(R, cosTheta, r, rRcp).x; // Entry;

    float cosHor       = ComputeCosineOfHorizonAngle(rRcp);
    bool  aboveHorizon = (cosTheta >= cosHor);

    if (aboveHorizon)
    {
        ray.maxDist = atmosEntryExit.y;
    }
    else // Intersect the planet
    {
        ray.maxDist = tGround;
    }

    assert(ray.maxDist > 0);

    float pathContribution = 0;
    float frequencyPdf     = 1.0/3.0;
    float pathPdf          = frequencyPdf;

    for (bounce = 1; bounce <= bounceCount; bounce++) // Bounces are indexed starting from 1
    {
        seed = permute(tileIndexInDispatch, tileCountInDispatch, s_RandomPrimes[bounce / 2]);
        rnd  = float3(cmj6D(pointIndex, bounce * 3 + 0, seed),
                      cmj6D(pointIndex, bounce * 3 + 1, seed),
                      cmj6D(pointIndex, bounce * 3 + 2, seed));

        float maxOptDepth = 0; // Air + aerosols + ozone
        maxOptDepth += OptDepthSpherExpMedium(r, rRcp, cosTheta, ray.maxDist, R,
                                              _AirSeaLevelExtinction[(uint)ray.frequency],
                                              _AirScaleHeight, _AirDensityFalloff).r;
        maxOptDepth += OptDepthSpherExpMedium(r, rRcp, cosTheta, ray.maxDist, R,
                                              _AerosolSeaLevelExtinction,
                                              _AerosolScaleHeight, _AerosolDensityFalloff).r;

        bool  geometryHit    = !aboveHorizon;
        float viewOpacity    = OpacityFromOpticalDepth(maxOptDepth);
        float sampledOpacity = rnd.x * (geometryHit ? 1 : viewOpacity);
        bool  volumeScatter  = (!geometryHit) || (sampledOpacity < viewOpacity);

        if (volumeScatter)
        {
            float sampledOptDepth = OpticalDepthFromOpacity(sampledOpacity);

            // Sample participating media.
            float t = SampleSpherExpMedium(sampledOptDepth, r, rRcp, cosTheta, R,
                                           float2(_AirSeaLevelExtinction[(uint)ray.frequency], _AerosolSeaLevelExtinction),
                                           float2(_AirScaleHeight, _AerosolScaleHeight),
                                           float2(_AirDensityFalloff, _AerosolDensityFalloff),
                                           viewOpacity, ray.maxDist);

            // Perform next event estimation.
            float3 P = ray.origin + t * ray.direction; // TODO: 1-D
            float3 D = ray.direction;                  // TODO: 1-D
            float3 N = normalize(P);                   // TODO: 1-D

            ApplySphericalSymmetry(P, D, /* -> */ r, rSq, rRcp, cosTheta); // TODO: optimize me :-(

            float airScaCoef = _AirSeaLevelScattering[(uint)ray.frequency]     * exp((R - r) * _AirDensityFalloff);
            float airAttCoef = _AirSeaLevelExtinction[(uint)ray.frequency]     * exp((R - r) * _AirDensityFalloff);
            float aerScaCoef = _AerosolSeaLevelScattering[(uint)ray.frequency] * exp((R - r) * _AerosolDensityFalloff);
            float aerAttCoef = _AerosolSeaLevelExtinction                      * exp((R - r) * _AerosolDensityFalloff);
            float totalAtt   = airAttCoef + aerAttCoef;

            float airAlbedo = airScaCoef * rcp(totalAtt);
            float aerAlbedo = aerScaCoef * rcp(totalAtt);

            for (uint lightIndex = 0; lightIndex < _DirectionalLightCount; lightIndex++)
            {
                DirectionalLightData light = _DirectionalLightDatas[lightIndex];

                // Use scalar or integer cores (more efficient).
                bool interactsWithSky = asint(light.distanceFromCamera) >= 0;

                if (!interactsWithSky) continue;

                float3 L = -light.forward.xyz;

                float NdotL  = dot(N, L); // TODO: 1-D
                float cosHor = ComputeCosineOfHorizonAngle(rRcp);

                if (NdotL > cosHor) // Shadow test
                {
                    float lightOptDepth = 0;
                    lightOptDepth += OptDepthSpherExpMedium(r, NdotL, R,
                                                            _AirSeaLevelExtinction[(uint)ray.frequency],
                                                            _AirScaleHeight, _AirDensityFalloff).r;
                    lightOptDepth += OptDepthSpherExpMedium(r, NdotL, R,
                                                            _AerosolSeaLevelExtinction,
                                                            _AerosolScaleHeight, _AerosolDensityFalloff).r;

                    float lightTransm     = TransmittanceFromOpticalDepth(lightOptDepth);
                    float emittedRadiance = light.color.rgb[(uint)ray.frequency];

                    float LdotD    = dot(L, D);
                    float airPhase = IsotropicPhaseFunction();
                    float aerPhase = CornetteShanksPhaseFunction(_AerosolAnisotropy, LdotD);

                    if (geometryHit)
                    {
                        // We select between volume and surface scattering events
                        // based on opacity, so the opacity factor cancels out.
                        viewOpacity = 1;
                    }

                    pathContribution += viewOpacity * (airAlbedo * airPhase + aerAlbedo * aerPhase) * (lightTransm * emittedRadiance);
                }
            }
        }
        else // Surface scattering
        {
            // Perform next event estimation.
            float3 P = ray.origin + tGround * ray.direction; // TODO: 1-D
            float3 D = ray.direction;                        // TODO: 1-D
            float3 N = normalize(P);                         // TODO: 1-D

            float groundAlbedo = _GroundAlbedo[(uint)ray.frequency];

            for (uint lightIndex = 0; lightIndex < _DirectionalLightCount; lightIndex++)
            {
                DirectionalLightData light = _DirectionalLightDatas[lightIndex];

                // Use scalar or integer cores (more efficient).
                bool interactsWithSky = asint(light.distanceFromCamera) >= 0;

                if (!interactsWithSky) continue;

                float3 L = -light.forward.xyz;

                float NdotL  = saturate(dot(N, L)); // TODO: 1-D
                float cosHor = 0;

                if (NdotL > cosHor) // Shadow test
                {
                    float lightOptDepth = 0;
                    lightOptDepth += OptDepthSpherExpMedium(R, NdotL, R,
                                                            _AirSeaLevelExtinction[(uint)ray.frequency],
                                                            _AirScaleHeight, _AirDensityFalloff).r;
                    lightOptDepth += OptDepthSpherExpMedium(R, NdotL, R,
                                                            _AerosolSeaLevelExtinction,
                                                            _AerosolScaleHeight, _AerosolDensityFalloff).r;

                    float lightTransm     = TransmittanceFromOpticalDepth(lightOptDepth);
                    float emittedRadiance = light.color.rgb[(uint)ray.frequency];

                    if (geometryHit)
                    {
                        // We select between volume and surface scattering events
                        // based on opacity, so the opacity factor cancels out.
                        viewOpacity = 1;
                    }

                    // We sample proportionally to 'viewOpacity', so it cancels out.
                    pathContribution += viewOpacity * (groundAlbedo * Lambert()) * (lightTransm * emittedRadiance) * NdotL;
                }
            }
        }
    }

    radiance[(uint)ray.frequency] += pathContribution / pathPdf;

    return float3(radiance[0], radiance[1], radiance[2]);
}

// Floating-point atomics are not supported. Use fixed-point math in units of HALF_MIN instead.
groupshared uint g_RadianceR[GROUP_SIZE_2D];
groupshared uint g_RadianceG[GROUP_SIZE_2D];
groupshared uint g_RadianceB[GROUP_SIZE_2D];
groupshared uint g_SampleCnt[GROUP_SIZE_2D];

[numthreads(GROUP_SIZE_1D, GROUP_SIZE_1D, 1)]
void main(uint2 groupCoordInDispatch  : SV_GroupID,
          uint2 threadCoordInGroup    : SV_GroupThreadID,
          uint  threadIndexInGroup    : SV_GroupIndex,
          uint2 threadCoordInDispatch : SV_DispatchThreadID)
{
    if (_PassIndex >= _NumPaths) return;

    const uint groupIndexInDispatch = groupCoordInDispatch.y * _DispatchWidth + groupCoordInDispatch.x;

    // Planet-relative coordinates.
    const float3 origin = _WorldSpaceCameraPos - _PlanetCenterPosition;

    uint2  outPositionSS;
    float3 radiance = PathTraceSky(groupCoordInDispatch, groupIndexInDispatch,
                                   threadCoordInGroup, _DispatchThreadCount,
                                   GROUP_SIZE_1D, TILE_SIZE_1D, _BounceCount, _PassIndex,
                                   origin, outPositionSS);

    // Find the corresponding coordinate in the groupshared memory.
    uint outPositionGS = (outPositionSS.y % GROUP_SIZE_1D) * GROUP_SIZE_1D
                       + (outPositionSS.x % GROUP_SIZE_1D);

    // Full clear.
    g_RadianceR[threadIndexInGroup] = 0;
    g_RadianceG[threadIndexInGroup] = 0;
    g_RadianceB[threadIndexInGroup] = 0;
    g_SampleCnt[threadIndexInGroup] = 0;
    // Partial fill.
    GroupMemoryBarrierWithGroupSync();
    InterlockedAdd(g_RadianceR[outPositionGS], round(radiance.r * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceG[outPositionGS], round(radiance.g * 16384)); // Fixed-point
    InterlockedAdd(g_RadianceB[outPositionGS], round(radiance.b * 16384)); // Fixed-point
    InterlockedAdd(g_SampleCnt[outPositionGS], 1);
    // Full load.
    uint sampleCount;
    GroupMemoryBarrierWithGroupSync();
    radiance.r  = g_RadianceR[threadIndexInGroup] * rcp(16384);
    radiance.g  = g_RadianceG[threadIndexInGroup] * rcp(16384);
    radiance.b  = g_RadianceB[threadIndexInGroup] * rcp(16384);
    sampleCount = g_SampleCnt[threadIndexInGroup];

    // // We store the sample count in the alpha channel.
    float3 oldRadiance    = _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)].rgb * GetInversePreviousExposureMultiplier();
    float  oldSampleCount = round(_ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)].a);
    float  newSampleCount = oldSampleCount + sampleCount;
    float4 newValue       = float4((oldRadiance * oldSampleCount + radiance) * rcp(max(newSampleCount, 1)), newSampleCount);
    newValue.rgb *= GetCurrentExposureMultiplier(); // Only the full-screen pass is pre-exposed
    _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)] = newValue;
}
